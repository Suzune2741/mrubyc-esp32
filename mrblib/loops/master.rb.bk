class ILI934X
    COLUMN_SET = 0x2a
    PAGE_SET = 0x2b
    RAM_WRITE = 0x2c
    RAM_READ = 0x2e
    DISPLAY_ON = 0x29
    WAKE = 0x11
    LINE_SET = 0x37
    MADCTL = 0x36
    DISPLAY_INVERSION_ON = 0x21

    _HEIGHT = 320
    _WIDTH = 240

    def initialize(mosi, clk, cs, dc, rst, bl) # add:ILI9342C on M5Stack
      p "ili934x initializing..."
      
      @spi = SPI.new(mosi, mosi, clk, cs, dc, rst, bl)
      if(bl >= 0)
        @bl = GPIO.new(bl, GPIO::OUT)
      end
      init(bl)
      p "ili934x initializing finished."
    end

    def init(bl)
      @spi.write_command(0xc8)
      @spi.write_data(0xff,0x93,0x42)
      @spi.write_command(0xc0)
      @spi.write_data(0x12,0x12)
      @spi.write_command(0xc1)
      @spi.write_data(0x03)
      @spi.write_command(0xb0)
      @spi.write_data(0xe0)
      @spi.write_command(0xf6)
      @spi.write_data(0x00, 0x01, 0x01)
      @spi.write_command(0x36)
      @spi.write_data(0x08)  # Memory Access Control
      @spi.write_command(0x3a)
      @spi.write_data(0x55)  # Pixel Format
      @spi.write_command(0xb6)
      @spi.write_data(0x08,0x82,0x27)  # Display Function Control
      @spi.write_command(0xe0)
      @spi.write_data(0x00,0x0c,0x11,0x04,0x11,0x08,0x37,0x89,0x4c,0x06,0x0c,0x0a,0x2e,0x34,0x0f)  # Set Gamma
      @spi.write_command(0xe1)
      @spi.write_data(0x00,0x0b,0x11,0x05,0x13,0x09,0x33,0x67,0x48,0x07,0x0e,0x0b,0x2e,0x33,0x0f)  # Set Gamma
      # operations.each do |command, data|
      #   # @spi.write_command(command)
      #   # @spi.write_data(data)
      # end
      p "ppppp"
      @spi.write_command(0x11)
      @spi.write_command(0x29)
      if(bl >= 0)
        @bl.write(1) # add:ILI9342C on M5Stack
      end
      @spi.write_command(0x21)
      p "init finish"
    end

    def drawPixel(x, y, color=nil)
      p x, y
      if x < 0 || x > 320 || y < 0 || y > 240 
          return
      end
      @spi.write_command(0x2a)
      @spi.write_address(x, x)
      @spi.write_command(0x2b)
      @spi.write_address(y, y)
      @spi.write_command(0x2c)
      @spi.write_data_word(color)
    end

    def drawRectangle(x1, x2, y1, y2, color=nil)
      # if x < 0 || x > 320 || y < 0 || y > 240 
      #     return
      # end
      @spi.write_command(0x2a)
      @spi.write_address(x1, x2)
      @spi.write_command(0x2b)
      @spi.write_address(y1, y2)
      @spi.write_command(0x2c)
      (x2 - x1).times do
        @spi.write_color(color, y2 - y1 + 1)
      end
    end

    # def fill_rectangle(x, y, w, h, color):
    #     x = min(@width - 1, max(0, x))
    #     y = min(@height - 1, max(0, y))
    #     w = min(@width - x, max(1, w))
    #     h = min(@height - y, max(1, h))
    #     @_block(x, y, x + w - 1, y + h - 1, b'')
    #     chunks, rest = divmod(w * h, 512)
    #     if chunks:
    #         data = ustruct.pack(">H", color) * 512
    #         for count in range(chunks):
    #             @_data(data)
    #     data = ustruct.pack(">H", color) * rest
    #     @_data(data)

    # def fill(color):
    #     @fill_rectangle(0, 0, @width, @height, color)

    # def char(char, x, y, color=0xffff, background=0x0000):
    #     buffer = bytearray(8)
    #     framebuffer = framebuf.FrameBuffer1(buffer, 8, 8)
    #     framebuffer.text(char, 0, 0)
    #     color = ustruct.pack(">H", color)
    #     background = ustruct.pack(">H", background)
    #     data = bytearray(2 * 8 * 8)
    #     for c, byte in enumerate(buffer):
    #         for r in range(8):
    #             if byte & (1 << r):
    #                 data[r * 8 * 2 + c * 2] = color[0]
    #                 data[r * 8 * 2 + c * 2 + 1] = color[1]
    #             else:
    #                 data[r * 8 * 2 + c * 2] = background[0]
    #                 data[r * 8 * 2 + c * 2 + 1] = background[1]
    #     @_block(x, y, x + 7, y + 7, data)

    # def text(text, x, y, color=0xffff, background=0x0000, wrap=nil,
    #          vwrap=nil, clear_eol=False):
    #     if wrap is nil:
    #         wrap = @width - 8
    #     if vwrap is nil:
    #         vwrap = @height - 8
    #     tx = x
    #     ty = y

    #     def new_line():
    #         nonlocal tx, ty

    #         tx = x
    #         ty += 8
    #         if ty >= vwrap:
    #             ty = y

    #     for char in text:
    #         if char == '\n':
    #             if clear_eol and tx < wrap:
    #                 @fill_rectangle(tx, ty, wrap - tx + 7, 8, background)
    #             new_line()
    #         else:
    #             if tx >= wrap:
    #                 new_line()
    #             @char(char, tx, ty, color, background)
    #             tx += 8
    #     if clear_eol and tx < wrap:
    #         @fill_rectangle(tx, ty, wrap - tx + 7, 8, background)

    # def scroll(dy=nil):
    #     if dy is nil:
    #         return @_scroll
    #     @_scroll = (@_scroll + dy) % @height
    #     @_write(_LINE_SET, ustruct.pack('>H', @_scroll))

    def self.color(r, g, b)
      return (r & 0xf8) << 8 | (g & 0xfc) << 3 | b >> 3
    end
end
display = ILI934X.new(23, 18, 14, 27, 33, 32)
p display
i = 0
# display.drawRectangle(0, 100, 0, 100, ILI934X.color(255,0,0))
while(1)
  display.drawPixel(i, i, ILI934X.color(255, 255, 255))
  i += 1
  sleep(1)
end